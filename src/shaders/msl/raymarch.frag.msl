#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct SDFObject
{
    float4x4 transform;
    float4 params;
    uint kind;
    uint op;
    float smooth_factor;
    float scale;
    float3 color;
    short visible;
    uint obj_id;
    spvUnsafeArray<float, 3> _pad;
};

struct SceneInfo
{
    float dist;
    uint index;
};

struct SdfCount
{
    uint sdf_count;
};

struct SDFObject_1
{
    float4x4 transform;
    float4 params;
    uint kind;
    uint op;
    float smooth_factor;
    float scale;
    packed_float3 color;
    uint visible;
    uint obj_id;
    float _pad[3];
};

struct SdfBuffer
{
    SDFObject_1 objects[1];
};

struct Indices
{
    uint indices[1];
};

struct CameraBlock
{
    float2 resolution;
    float2 _pad;
    packed_float3 cam_pos;
    float fov;
    float3x3 cam_rot;
};

struct main0_out
{
    float4 outColor [[color(0)]];
};

struct main0_in
{
    float2 fragTexCoord [[user(locn0)]];
};

static inline __attribute__((always_inline))
float sdSphere(thread const float3& p, thread const float& r)
{
    return length(p) - r;
}

static inline __attribute__((always_inline))
float sdBox(thread const float3& p, thread const float3& b, thread const float& r)
{
    float3 q = (abs(p) - b) + float3(r);
    return (length(fast::max(q, float3(0.0))) + fast::min(fast::max(q.x, fast::max(q.y, q.z)), 0.0)) - r;
}

static inline __attribute__((always_inline))
float sdCylinder(thread const float3& p, thread const float2& h)
{
    float2 d = abs(float2(length(p.xz), p.y)) - h;
    return fast::min(fast::max(d.x, d.y), 0.0) + length(fast::max(d, float2(0.0)));
}

static inline __attribute__((always_inline))
float sdTorus(thread const float3& p, thread const float2& t)
{
    float2 q = float2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

static inline __attribute__((always_inline))
float evaluateSDF(thread const SDFObject& obj, thread const float3& p)
{
    float3 local_p = (float3x3(obj.transform[0].xyz, obj.transform[1].xyz, obj.transform[2].xyz) * (p - obj.transform[3].xyz)) / float3(obj.scale);
    if (obj.kind == 0u)
    {
        float3 param = local_p;
        float param_1 = obj.params.x;
        return sdSphere(param, param_1) * obj.scale;
    }
    if (obj.kind == 1u)
    {
        float3 param_2 = local_p;
        float3 param_3 = obj.params.xyz;
        float param_4 = obj.params.w;
        return sdBox(param_2, param_3, param_4) * obj.scale;
    }
    if (obj.kind == 2u)
    {
        float3 param_5 = local_p;
        float2 param_6 = obj.params.xy;
        return sdCylinder(param_5, param_6) * obj.scale;
    }
    if (obj.kind == 3u)
    {
        float3 param_7 = local_p;
        float2 param_8 = obj.params.xy;
        return sdTorus(param_7, param_8) * obj.scale;
    }
    return 0.0;
}

static inline __attribute__((always_inline))
float unionOp(thread const float& d1, thread const float& d2, thread const float& k)
{
    if (k < 9.9999997473787516355514526367188e-05)
    {
        return fast::min(d1, d2);
    }
    float h = fast::clamp(0.5 + ((0.5 * (d2 - d1)) / k), 0.0, 1.0);
    return mix(d2, d1, h) - ((k * h) * (1.0 - h));
}

static inline __attribute__((always_inline))
float subtraction(thread const float& d1, thread const float& d2, thread const float& k)
{
    if (k < 9.9999997473787516355514526367188e-05)
    {
        return fast::max(-d1, d2);
    }
    float h = fast::clamp(0.5 - ((0.5 * (d2 + d1)) / k), 0.0, 1.0);
    return mix(d2, -d1, h) + ((k * h) * (1.0 - h));
}

static inline __attribute__((always_inline))
float intersection(thread const float& d1, thread const float& d2, thread const float& k)
{
    if (k < 9.9999997473787516355514526367188e-05)
    {
        return fast::max(d1, d2);
    }
    float h = fast::clamp(0.5 - ((0.5 * (d2 - d1)) / k), 0.0, 1.0);
    return mix(d2, d1, h) + ((k * h) * (1.0 - h));
}

static inline __attribute__((always_inline))
float applyOperation(thread const float& d1, thread const float& d2, thread const uint& op, thread const float& k)
{
    if (op == 1u)
    {
        float param = d1;
        float param_1 = d2;
        float param_2 = k;
        return unionOp(param, param_1, param_2);
    }
    if (op == 2u)
    {
        float param_3 = d1;
        float param_4 = d2;
        float param_5 = k;
        return subtraction(param_3, param_4, param_5);
    }
    if (op == 3u)
    {
        float param_6 = d1;
        float param_7 = d2;
        float param_8 = k;
        return intersection(param_6, param_7, param_8);
    }
    return d1;
}

static inline __attribute__((always_inline))
SceneInfo getDist(thread const float3& p, constant SdfCount& _410, const device SdfBuffer& _425, const device Indices& _445)
{
    float result_dist = 100.0;
    uint index = 0u;
    uint obj_id = 0u;
    if (_410.sdf_count == 0u)
    {
        return SceneInfo{ 100.0, 0u };
    }
    uint current_obj = _425.objects[0].obj_id;
    float group_dist = 100.0;
    uint group_index = 0u;
    SDFObject obj;
    for (uint i = 0u; i < _410.sdf_count; i++)
    {
        obj.transform = _425.objects[_445.indices[i]].transform;
        obj.params = _425.objects[_445.indices[i]].params;
        obj.kind = _425.objects[_445.indices[i]].kind;
        obj.op = _425.objects[_445.indices[i]].op;
        obj.smooth_factor = _425.objects[_445.indices[i]].smooth_factor;
        obj.scale = _425.objects[_445.indices[i]].scale;
        obj.color = float3(_425.objects[_445.indices[i]].color);
        obj.visible = short(_425.objects[_445.indices[i]].visible != 0u);
        obj.obj_id = _425.objects[_445.indices[i]].obj_id;
        obj._pad[0] = _425.objects[_445.indices[i]]._pad[0];
        obj._pad[1] = _425.objects[_445.indices[i]]._pad[1];
        obj._pad[2] = _425.objects[_445.indices[i]]._pad[2];
        if (obj.obj_id != current_obj)
        {
            if (group_dist < result_dist)
            {
                result_dist = group_dist;
                index = group_index;
            }
            current_obj = obj.obj_id;
            group_dist = 100.0;
        }
        if (!bool(obj.visible))
        {
            continue;
        }
        SDFObject param = obj;
        float3 param_1 = p;
        float d = evaluateSDF(param, param_1);
        float prev = group_dist;
        float param_2 = d;
        float param_3 = group_dist;
        uint param_4 = obj.op;
        float param_5 = obj.smooth_factor;
        group_dist = applyOperation(param_2, param_3, param_4, param_5);
        if (group_dist < prev)
        {
            group_index = i;
        }
    }
    if (group_dist < result_dist)
    {
        result_dist = group_dist;
        index = group_index;
    }
    return SceneInfo{ result_dist, index };
}

static inline __attribute__((always_inline))
SceneInfo rayMarch(thread const float3& ro, thread const float3& rd, thread const float& maxDist, constant SdfCount& _410, const device SdfBuffer& _425, const device Indices& _445)
{
    float dO = 0.0;
    uint index = 0u;
    for (int i = 0; i < 80; i++)
    {
        float3 p = ro + (rd * dO);
        float3 param = p;
        SceneInfo info = getDist(param, _410, _425, _445);
        dO += info.dist;
        index = info.index;
        bool _617 = dO > maxDist;
        bool _625;
        if (!_617)
        {
            _625 = abs(info.dist) < 0.001000000047497451305389404296875;
        }
        else
        {
            _625 = _617;
        }
        if (_625)
        {
            break;
        }
    }
    return SceneInfo{ dO, index };
}

static inline __attribute__((always_inline))
float3 getNormal(thread const float3& p, constant SdfCount& _410, const device SdfBuffer& _425, const device Indices& _445)
{
    float3 param = p + float3(0.001000000047497451305389404296875, -0.001000000047497451305389404296875, -0.001000000047497451305389404296875);
    float3 param_1 = p + float3(-0.001000000047497451305389404296875, -0.001000000047497451305389404296875, 0.001000000047497451305389404296875);
    float3 param_2 = p + float3(-0.001000000047497451305389404296875, 0.001000000047497451305389404296875, -0.001000000047497451305389404296875);
    float3 param_3 = p + float3(0.001000000047497451305389404296875);
    return fast::normalize((((float3(1.0, -1.0, -1.0) * getDist(param, _410, _425, _445).dist) + (float3(-1.0, -1.0, 1.0) * getDist(param_1, _410, _425, _445).dist)) + (float3(-1.0, 1.0, -1.0) * getDist(param_2, _410, _425, _445).dist)) + (float3(1.0) * getDist(param_3, _410, _425, _445).dist));
}

static inline __attribute__((always_inline))
float shadowMarch(thread const float3& ro, thread const float3& rd, thread const float& maxDist, constant SdfCount& _410, const device SdfBuffer& _425, const device Indices& _445)
{
    float dO = 0.0;
    for (int i = 0; i < 80; i++)
    {
        float3 param = ro + (rd * dO);
        float d = getDist(param, _410, _425, _445).dist;
        dO += d;
        if ((dO > maxDist) || (d < 0.001000000047497451305389404296875))
        {
            break;
        }
    }
    return dO;
}

static inline __attribute__((always_inline))
float getLight(thread const float3& p, constant SdfCount& _410, const device SdfBuffer& _425, const device Indices& _445)
{
    float3 lightPos = float3(5.0, 5.0, -5.0);
    float3 l = fast::normalize(lightPos - p);
    float3 param = p;
    float3 n = getNormal(param, _410, _425, _445);
    float dif = fast::clamp(dot(n, l), 0.0, 1.0);
    float lightDist = length(lightPos - p);
    float3 param_1 = p + ((n * 0.001000000047497451305389404296875) * 2.0);
    float3 param_2 = l;
    float param_3 = lightDist;
    float shadow = shadowMarch(param_1, param_2, param_3, _410, _425, _445);
    if (shadow < lightDist)
    {
        dif *= 0.300000011920928955078125;
    }
    return dif;
}

static inline __attribute__((always_inline))
float4 getGridColorAA(thread const float3& p, constant CameraBlock& _724)
{
    float2 coord = p.xz;
    float camDist = length(float3(_724.cam_pos) - p);
    float distFade = 1.0 - smoothstep(40.0, 90.0, camDist);
    float2 dx = dfdx(coord);
    float2 dy = dfdy(coord);
    float2 derivative = abs(float2(length(float2(dx.x, dy.x)), length(float2(dx.y, dy.y))));
    float lineWidth = mix(1.5, 0.5, smoothstep(5.0, 40.0, camDist));
    float2 grid = abs(fract(coord - float2(0.5)) - float2(0.5)) / (derivative * lineWidth);
    float line = fast::min(grid.x, grid.y);
    float alpha = 1.0 - fast::min(line, 1.0);
    float pixelSize = fast::max(derivative.x, derivative.y);
    alpha *= (1.0 - smoothstep(0.25, 0.5, pixelSize));
    alpha *= distFade;
    float3 color = float3(0.3499999940395355224609375, 0.3499999940395355224609375, 0.4000000059604644775390625);
    float xAxis = smoothstep(0.039999999105930328369140625, 0.008000000379979610443115234375, abs(coord.y));
    float zAxis = smoothstep(0.039999999105930328369140625, 0.008000000379979610443115234375, abs(coord.x));
    if (xAxis > 0.0)
    {
        color = float3(0.89999997615814208984375, 0.1500000059604644775390625, 0.1500000059604644775390625);
    }
    if (zAxis > 0.0)
    {
        color = float3(0.1500000059604644775390625, 0.4000000059604644775390625, 0.89999997615814208984375);
    }
    return float4(color, alpha);
}

fragment main0_out main0(main0_in in [[stage_in]], constant CameraBlock& _724 [[buffer(0)]], constant SdfCount& _410 [[buffer(1)]], const device Indices& _445 [[buffer(2)]], const device SdfBuffer& _425 [[buffer(3)]])
{
    main0_out out = {};
    float2 uv = (in.fragTexCoord * 2.0) - float2(1.0);
    uv.x *= (_724.resolution.x / _724.resolution.y);
    float fov_factor = tan(_724.fov * 0.5);
    uv *= fov_factor;
    float3 rd = fast::normalize(_724.cam_rot * float3(uv.x, uv.y, 1.0));
    float3 ro = float3(_724.cam_pos);
    float gridT = 101.0;
    if (abs(rd.y) > 9.9999999747524270787835121154785e-07)
    {
        float t = (-ro.y) / rd.y;
        if (t > 0.0)
        {
            gridT = t;
        }
    }
    float3 param = ro;
    float3 param_1 = rd;
    float param_2 = 100.0;
    SceneInfo info = rayMarch(param, param_1, param_2, _410, _425, _445);
    float3 col = float3(0.1500000059604644775390625, 0.1500000059604644775390625, 0.180000007152557373046875);
    if (info.dist < 100.0)
    {
        float3 p = ro + (rd * info.dist);
        float3 param_3 = p;
        float light = getLight(param_3, _410, _425, _445);
        float3 baseColor = float3(_425.objects[info.index].color);
        col = (baseColor * light) + (baseColor * 0.100000001490116119384765625);
        col += float3(0.02999999932944774627685546875, 0.02999999932944774627685546875, 0.0500000007450580596923828125);
        col = powr(col, float3(0.4544999897480010986328125));
    }
    if ((info.dist > gridT) && (gridT <= 100.0))
    {
        float3 p_1 = ro + (rd * gridT);
        float3 param_4 = p_1;
        float4 grid = getGridColorAA(param_4, _724);
        col = mix(col, grid.xyz, float3(grid.w));
    }
    out.outColor = float4(col, 1.0);
    return out;
}

