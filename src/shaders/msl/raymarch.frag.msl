#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct SDFObject
{
    float3 position;
    uint sdf_type;
    float4 params;
    float3 color;
    uint operation;
    float smooth_factor;
    short visible;
    spvUnsafeArray<float, 2> _pad;
};

struct SceneInfo
{
    float dist;
    uint index;
};

struct SDFObject_1
{
    packed_float3 position;
    uint sdf_type;
    float4 params;
    packed_float3 color;
    uint operation;
    float smooth_factor;
    uint visible;
    float _pad[2];
};

struct SceneBlock
{
    uint object_count;
    uint _pad2[3];
    SDFObject_1 objects[1];
};

struct CameraBlock
{
    float2 resolution;
    float2 _pad;
    packed_float3 cam_pos;
    float fov;
    float3x3 cam_rot;
};

struct main0_out
{
    float4 outColor [[color(0)]];
};

struct main0_in
{
    float2 fragTexCoord [[user(locn0)]];
};

static inline __attribute__((always_inline))
float sdSphere(thread const float3& p, thread const float& r)
{
    return length(p) - r;
}

static inline __attribute__((always_inline))
float sdBox(thread const float3& p, thread const float3& b, thread const float& r)
{
    float3 q = (abs(p) - b) + float3(r);
    return (length(fast::max(q, float3(0.0))) + fast::min(fast::max(q.x, fast::max(q.y, q.z)), 0.0)) - r;
}

static inline __attribute__((always_inline))
float sdCylinder(thread const float3& p, thread const float2& h)
{
    float2 d = abs(float2(length(p.xz), p.y)) - h;
    return fast::min(fast::max(d.x, d.y), 0.0) + length(fast::max(d, float2(0.0)));
}

static inline __attribute__((always_inline))
float sdTorus(thread const float3& p, thread const float2& t)
{
    float2 q = float2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

static inline __attribute__((always_inline))
float evaluateSDF(thread const SDFObject& obj, thread const float3& p)
{
    float3 local_p = p - obj.position;
    if (obj.sdf_type == 0u)
    {
        float3 param = local_p;
        float param_1 = obj.params.x;
        return sdSphere(param, param_1);
    }
    if (obj.sdf_type == 1u)
    {
        float3 param_2 = local_p;
        float3 param_3 = obj.params.xyz;
        float param_4 = obj.params.w;
        return sdBox(param_2, param_3, param_4);
    }
    if (obj.sdf_type == 2u)
    {
        float3 param_5 = local_p;
        float2 param_6 = obj.params.xy;
        return sdCylinder(param_5, param_6);
    }
    if (obj.sdf_type == 3u)
    {
        float3 param_7 = local_p;
        float2 param_8 = obj.params.xy;
        return sdTorus(param_7, param_8);
    }
    return 1000.0;
}

static inline __attribute__((always_inline))
float unionOp(thread const float& d1, thread const float& d2, thread const float& k)
{
    if (k < 9.9999997473787516355514526367188e-05)
    {
        return fast::min(d1, d2);
    }
    float h = fast::clamp(0.5 + ((0.5 * (d2 - d1)) / k), 0.0, 1.0);
    return mix(d2, d1, h) - ((k * h) * (1.0 - h));
}

static inline __attribute__((always_inline))
float subtraction(thread const float& d1, thread const float& d2, thread const float& k)
{
    if (k < 9.9999997473787516355514526367188e-05)
    {
        return fast::max(-d1, d2);
    }
    float h = fast::clamp(0.5 - ((0.5 * (d2 + d1)) / k), 0.0, 1.0);
    return mix(d2, -d1, h) + ((k * h) * (1.0 - h));
}

static inline __attribute__((always_inline))
float intersection(thread const float& d1, thread const float& d2, thread const float& k)
{
    if (k < 9.9999997473787516355514526367188e-05)
    {
        return fast::max(d1, d2);
    }
    float h = fast::clamp(0.5 - ((0.5 * (d2 - d1)) / k), 0.0, 1.0);
    return mix(d2, d1, h) + ((k * h) * (1.0 - h));
}

static inline __attribute__((always_inline))
float applyOperation(thread const float& d1, thread const float& d2, thread const uint& op, thread const float& k)
{
    if (op == 1u)
    {
        float param = d1;
        float param_1 = d2;
        float param_2 = k;
        return unionOp(param, param_1, param_2);
    }
    if (op == 2u)
    {
        float param_3 = -d1;
        float param_4 = d2;
        float param_5 = k;
        return subtraction(param_3, param_4, param_5);
    }
    if (op == 3u)
    {
        float param_6 = d1;
        float param_7 = d2;
        float param_8 = k;
        return intersection(param_6, param_7, param_8);
    }
    return d1;
}

static inline __attribute__((always_inline))
SceneInfo getDist(thread const float3& p, const device SceneBlock& _390)
{
    float result_dist = 100.0;
    uint index = 0u;
    SDFObject obj;
    for (uint i = 0u; (i < _390.object_count) && (i < 128u); i++)
    {
        obj.position = float3(_390.objects[i].position);
        obj.sdf_type = _390.objects[i].sdf_type;
        obj.params = _390.objects[i].params;
        obj.color = float3(_390.objects[i].color);
        obj.operation = _390.objects[i].operation;
        obj.smooth_factor = _390.objects[i].smooth_factor;
        obj.visible = short(_390.objects[i].visible != 0u);
        obj._pad[0] = _390.objects[i]._pad[0];
        obj._pad[1] = _390.objects[i]._pad[1];
        if (!bool(obj.visible))
        {
            continue;
        }
        SDFObject param = obj;
        float3 param_1 = p;
        float obj_dist = evaluateSDF(param, param_1);
        float prev_dist = result_dist;
        float param_2 = obj_dist;
        float param_3 = result_dist;
        uint param_4 = obj.operation;
        float param_5 = obj.smooth_factor;
        result_dist = applyOperation(param_2, param_3, param_4, param_5);
        if (result_dist < prev_dist)
        {
            index = i;
        }
    }
    return SceneInfo{ result_dist, index };
}

static inline __attribute__((always_inline))
SceneInfo rayMarch(thread const float3& ro, thread const float3& rd, thread const float& maxDist, const device SceneBlock& _390)
{
    float dO = 0.0;
    uint index = 0u;
    for (int i = 0; i < 80; i++)
    {
        float3 p = ro + (rd * dO);
        float3 param = p;
        SceneInfo info = getDist(param, _390);
        dO += info.dist;
        index = info.index;
        bool _542 = dO > maxDist;
        bool _550;
        if (!_542)
        {
            _550 = abs(info.dist) < 0.001000000047497451305389404296875;
        }
        else
        {
            _550 = _542;
        }
        if (_550)
        {
            break;
        }
    }
    return SceneInfo{ dO, index };
}

static inline __attribute__((always_inline))
float3 getNormal(thread const float3& p, const device SceneBlock& _390)
{
    float3 param = p + float3(0.001000000047497451305389404296875, -0.001000000047497451305389404296875, -0.001000000047497451305389404296875);
    float3 param_1 = p + float3(-0.001000000047497451305389404296875, -0.001000000047497451305389404296875, 0.001000000047497451305389404296875);
    float3 param_2 = p + float3(-0.001000000047497451305389404296875, 0.001000000047497451305389404296875, -0.001000000047497451305389404296875);
    float3 param_3 = p + float3(0.001000000047497451305389404296875);
    return fast::normalize((((float3(1.0, -1.0, -1.0) * getDist(param, _390).dist) + (float3(-1.0, -1.0, 1.0) * getDist(param_1, _390).dist)) + (float3(-1.0, 1.0, -1.0) * getDist(param_2, _390).dist)) + (float3(1.0) * getDist(param_3, _390).dist));
}

static inline __attribute__((always_inline))
float shadowMarch(thread const float3& ro, thread const float3& rd, thread const float& maxDist, const device SceneBlock& _390)
{
    float dO = 0.0;
    for (int i = 0; i < 80; i++)
    {
        float3 param = ro + (rd * dO);
        float d = getDist(param, _390).dist;
        dO += d;
        if ((dO > maxDist) || (d < 0.001000000047497451305389404296875))
        {
            break;
        }
    }
    return dO;
}

static inline __attribute__((always_inline))
float getLight(thread const float3& p, const device SceneBlock& _390)
{
    float3 lightPos = float3(5.0, 5.0, -5.0);
    float3 l = fast::normalize(lightPos - p);
    float3 param = p;
    float3 n = getNormal(param, _390);
    float dif = fast::clamp(dot(n, l), 0.0, 1.0);
    float lightDist = length(lightPos - p);
    float3 param_1 = p + ((n * 0.001000000047497451305389404296875) * 2.0);
    float3 param_2 = l;
    float param_3 = lightDist;
    float shadow = shadowMarch(param_1, param_2, param_3, _390);
    if (shadow < lightDist)
    {
        dif *= 0.300000011920928955078125;
    }
    return dif;
}

static inline __attribute__((always_inline))
float4 getGridColorAA(thread const float3& p, constant CameraBlock& _650)
{
    float2 coord = p.xz;
    float camDist = length(float3(_650.cam_pos) - p);
    float distFade = 1.0 - smoothstep(40.0, 90.0, camDist);
    float2 dx = dfdx(coord);
    float2 dy = dfdy(coord);
    float2 derivative = abs(float2(length(float2(dx.x, dy.x)), length(float2(dx.y, dy.y))));
    float lineWidth = mix(1.5, 0.5, smoothstep(5.0, 40.0, camDist));
    float2 grid = abs(fract(coord - float2(0.5)) - float2(0.5)) / (derivative * lineWidth);
    float line = fast::min(grid.x, grid.y);
    float alpha = 1.0 - fast::min(line, 1.0);
    float pixelSize = fast::max(derivative.x, derivative.y);
    alpha *= (1.0 - smoothstep(0.25, 0.5, pixelSize));
    alpha *= distFade;
    float3 color = float3(0.3499999940395355224609375, 0.3499999940395355224609375, 0.4000000059604644775390625);
    float xAxis = smoothstep(0.039999999105930328369140625, 0.008000000379979610443115234375, abs(coord.y));
    float zAxis = smoothstep(0.039999999105930328369140625, 0.008000000379979610443115234375, abs(coord.x));
    if (xAxis > 0.0)
    {
        color = float3(0.89999997615814208984375, 0.1500000059604644775390625, 0.1500000059604644775390625);
    }
    if (zAxis > 0.0)
    {
        color = float3(0.1500000059604644775390625, 0.4000000059604644775390625, 0.89999997615814208984375);
    }
    return float4(color, alpha);
}

fragment main0_out main0(main0_in in [[stage_in]], constant CameraBlock& _650 [[buffer(0)]], const device SceneBlock& _390 [[buffer(1)]])
{
    main0_out out = {};
    float2 uv = (in.fragTexCoord * 2.0) - float2(1.0);
    uv.x *= (_650.resolution.x / _650.resolution.y);
    float fov_factor = tan(_650.fov * 0.5);
    uv *= fov_factor;
    float3 rd = fast::normalize(_650.cam_rot * float3(uv.x, uv.y, 1.0));
    float3 ro = float3(_650.cam_pos);
    float gridT = 101.0;
    if (abs(rd.y) > 9.9999999747524270787835121154785e-07)
    {
        float t = (-ro.y) / rd.y;
        if (t > 0.0)
        {
            gridT = t;
        }
    }
    float3 param = ro;
    float3 param_1 = rd;
    float param_2 = 100.0;
    SceneInfo info = rayMarch(param, param_1, param_2, _390);
    float3 col = float3(0.1500000059604644775390625, 0.1500000059604644775390625, 0.180000007152557373046875);
    if (info.dist < 100.0)
    {
        float3 p = ro + (rd * info.dist);
        float3 param_3 = p;
        float light = getLight(param_3, _390);
        float3 baseColor = float3(_390.objects[info.index].color);
        col = (baseColor * light) + (baseColor * 0.100000001490116119384765625);
        col += float3(0.02999999932944774627685546875, 0.02999999932944774627685546875, 0.0500000007450580596923828125);
        col = powr(col, float3(0.4544999897480010986328125));
    }
    if ((info.dist > gridT) && (gridT <= 100.0))
    {
        float3 p_1 = ro + (rd * gridT);
        float3 param_4 = p_1;
        float4 grid = getGridColorAA(param_4, _650);
        col = mix(col, grid.xyz, float3(grid.w));
    }
    out.outColor = float4(col, 1.0);
    return out;
}

